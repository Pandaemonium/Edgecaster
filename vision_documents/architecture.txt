EDGECASTER ARCHITECTURE GUIDE
High-Level Overview and Refactor Roadmap
Updated: 2025-12-13 (Overlay widget layers; HUD active in dungeon + inventory)

This document orients new contributors to the current structure.
It must remain concise, accurate, and immediately useful as a project primer.


===============================================================================
SECTION 1 — LAYER RESPONSIBILITIES

SCENES (edgecaster/scenes/)
Own:
- Input interpretation (via GameCommand)
- Scene-local UI state (menus, dialogs, targeting, ability bar state sync)
- Scene transitions
- High-level gameplay intent routing
- Declaring which overlay widget layers should be active (overlay_layers)

Do NOT:
- Perform low-level rendering
- Interpret raw pygame display transforms
- Implement world rules or simulation logic

Key scenes:
- manager.py                     scene stack + transitions + overlay layer service
- dungeon.py                     primary gameplay; owns TargetMode & UI routing
- urgent_message_scene.py        popup system using panel-local rendering
- dialogue_scene.py              dialogue trees + callbacks
- inventory_scene.py             nested inventories (migrating to widgets)
- options, keybinds, character creation, etc.


-------------------------------------------------------------------------------
RENDERERS (edgecaster/render/)
Pure view layer.

ascii.py:
- Draws map, entities, overlays
- Draws panel-local UI for popup/menu scenes
- Transitional: some HUD drawing may remain, but target architecture is:
  **scene-owned widget trees** with renderer remaining draw-only

Renderers never:
- Read events
- Interpret commands
- Store gameplay or UI state


-------------------------------------------------------------------------------
INPUT (scenes/game_input.py)
Single conversion point:
Pygame Event → GameCommand(kind=...)

Scenes interpret GameCommands; renderer remains input-agnostic.

Keybinds:
- DEFAULT_BINDINGS merged with user settings
- Commands auto-listed in keybinds UI
- Scene-context conflict resolution


-------------------------------------------------------------------------------
GAME CORE (edgecaster/game.py)
Authoritative simulation:
- Entities, actors, stats
- Turn updates, movement, collisions, combat
- Fractal mechanics, patterns, rune interactions
- Procedural world state, RNG

Does NOT:
- Know about rendering
- Contain UI logic or targeting logic

Data:
- POIs (content/pois.yaml)
- Entities (content/entities.yaml)
- Enemies (content/enemies.yaml)
- NPCs (npcs.py)


-------------------------------------------------------------------------------
SYSTEMS (edgecaster/systems/)
Pure logic:
- actions.py         → Action metadata + targeting rules
- abilities.py       → Actor ability lists
- patterns/*         → Fractal generation
- ai.py              → Behavior stubs

Recent:
✓ Targeting metadata centralized  
✓ AbilityBar is metadata-driven  
✓ Action parameters surface automatically into config overlay


===============================================================================
SECTION 2 — VISUAL SCENE SYSTEM (TRANSFORM & PANEL PIPELINE)

visuals.py introduces:
- VisualProfile (scale, offset, rotate, alpha, flip)
- apply_visual_panel(...)  → transforms & blits a panel
- unproject_mouse(...)     → invert transform for accurate hit-tests

Panel-local rendering:
- Popups, menus, dialogs draw into a dedicated panel surface
- Transform applied at blit-time only (logic stays axis-aligned)

Enables:
- Rotated inventories ("clockwise")
- Ghost/alpha menus
- Recursive menu distortions
- Shared transform math for dungeon-space effects


===============================================================================
SECTION 3 — TARGETING (UNIFIED TARGETMODE)

TargetingSpec (in actions.py):
- kind: tile | vertex | look
- mode: aim | terminus | inspect
- range parameters

TargetState (scene-local):
- cursor, origin, mode, etc.

DungeonScene:
- Moves cursor, confirms/cancels, triggers actions

Renderer:
- Draws cursor only (no targeting logic)


===============================================================================
SECTION 4 — WIDGET SYSTEM AND OVERLAY LAYERS

Widget foundation:
- Location: edgecaster/ui/widgets.py
- WidgetContext(surface, game, scene, renderer)
- Widget base class (rect, layout(), draw(), handle_event(), update())
- Composition + layout containers (VBox/HBox) + interactive widgets as they are added

Intended ownership:
- Scenes own widget trees and route input.
- Renderers remain draw-only; widgets may *use* renderer helpers (fonts/colors).

Overlay widget layers (general mechanism):
- SceneManager maintains a registry of named widget layers (e.g. "hud").
- Scenes declare which layers they want via `overlay_layers` (e.g. {"hud"}).
- Popup scenes draw dimming first, then overlay layers, so overlays remain bright/live.
- This allows live-updating HUD while interacting with inventory/popup scenes.

Current status:
✓ Independent status/header HUD widget exists
✓ HUD overlay layer is active during both dungeon and inventory scenes
✓ Temporary F8 debug overlay exists in dungeon.py as scaffolding; remove after
  AbilityBar widgetization/input verification


===============================================================================
SECTION 5 — DATA-DRIVEN ENTITIES & INHERITANCE

YAML prototypes define:
- parent, glyph, color
- description (inherited)
- stats, tags, behaviors

Runtime entities reference fully-resolved archetypes.

Look-mode automatically displays inherited descriptions.


===============================================================================
SECTION 6 — ONBOARDING NOTES

- Renderer = draw-only
- Scenes = UI/state/intent + event routing
- Game = simulation only
- Systems = reusable logic modules
- VisualProfiles = panel/window-level transforms
- Widgets = UI composition inside panel-local rendering
- Overlay layers = reusable cross-scene widget layers (HUD, etc.)
- Currency: simulation lives in game.py (wallet + adjust_currency; currency items in content/entities.yaml with tags currency/amount). Renderer draws currency items with PNG icons from assets/icons/ (project root), HUD header shows the balance via StatusHeaderWidget.
- Assets: loaded from project root assets/ (e.g., assets/icons/bismuth.png); keep renderer references project-rooted, not package-relative. Avoid embedding assets inside the edgecaster/ package.

Current strategic work:
- HUD → Ability Bar → MenuScene (generalized widget-based menus)
- Two-pane inventory (list + details)
- Keybindings/options unification
- Reduce ad-hoc coordinate math everywhere
- Expand transform-based UI effects
