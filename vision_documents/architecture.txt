EDGECASTER ARCHITECTURE GUIDE
High-Level Overview and Refactor Roadmap
Updated: 2025-12-08 (entity-driven abilities update integrated)

This document orients new contributors to the current post-ascii-purge structure.
It must remain concise, accurate, and immediately useful as a project primer.

===============================================================================
SECTION 1 — LAYER RESPONSIBILITIES

SCENES (edgecaster/scenes/)
Own:
- Input interpretation (via GameCommand)
- UI state (dialogs, config, ability bar, targeting)
- Scene transitions
- High-level gameplay intentions (“Player activates this ability”)

Do NOT:
- Draw pixels
- Contain renderer logic
- Bypass the GameCore

Key scenes:
- manager.py            scene stack + transitions
- dungeon.py            primary gameplay; owns ability bar + targeting
- inventory_scene.py    nested inventory UI
- fractal_editor_scene.py
- dialogue_scene.py
- urgent_message_scene.py

-------------------------------------------------------------------------------
RENDERERS (edgecaster/render/)
Pure view layer.

ascii.py:
- Draws everything (map, entities, UI overlays)
- Computes hitboxes for mouse interactions
- Holds *only* lightweight visual state

Renderers do NOT:
- Read keyboard/mouse events
- Trigger actions
- Store gameplay state

-------------------------------------------------------------------------------
INPUT (edgecaster/scenes/game_input.py)
Single input translation layer:
Pygame Event → GameCommand(kind="move"|"ability_hotkey"|...).
Scenes interpret commands; renderers never touch input.

-------------------------------------------------------------------------------
GAME CORE (edgecaster/game.py)
Authoritative world state:
- Entities, actors, positions, combat
- Rune graph, fractal operators, generator/illuminator logic
- Turn updates, RNG, world state

GameCore does NOT:
- Interpret input
- Know anything about the renderer

-------------------------------------------------------------------------------
SYSTEMS (edgecaster/systems/)
Pure logic modules:
- actions.py       → ActionDef registry + metadata (show_in_bar, icons, sub-buttons)
- abilities.py     → Builds ability list from host actions; routes effects
- patterns/*       → Fractal generation
- ai.py            → Behavior logic

IMPORTANT (NEW):
✓ Action UIs are driven entirely by metadata in actions.py.  
✓ AbilityBarRenderer is purely a consumer of ActionDef metadata.  
✓ Scenes route all activation and per-ability adjustments.

===============================================================================
SECTION 2 — ASCII PURGE STATUS

Originally ascii.py owned input, UI logic, targeting, and sometimes gameplay.
Now:

✓ All input lives in DungeonScene  
✓ Ability system fully extracted into systems/abilities  
✓ AbilityBarState (scene) + AbilityBarRenderer (view) are clean  
✓ Targeting logic partly migrated; renderer now draws cursor only  
✓ Action icons + sub-buttons driven by actions.py  
✓ UI state (aim/hover/target/config) is scene-owned (DungeonUIState); renderer consumes view-model only  
✓ Lorenz simulation lives in game/lorenz; renderer draws from game-provided points/trails


Next:
→ Complete unified TargetMode

===============================================================================
SECTION 3 — ABILITY SYSTEM (CURRENT BEHAVIOR)

Pipeline:
Actor.actions (from YAML or class)  
→ systems/abilities.build_abilities  
→ AbilityBarState (scene)  
→ AbilityBarRenderer (view)  
→ DungeonScene._handle_command  
→ trigger_ability_effect / queue_player_action

Highlights:
✓ Ability bar now reflects the **current host actor’s actions**  
✓ show_in_bar=True determines visibility  
✓ Icons, labels, tooltips, sub-buttons imported from actions.py  
✓ Body-swapping cleanly switches ability sets  
✓ Easy extension: add an action to a monster → it appears in the bar if flagged

IMPORTANT (NEW):
**Kochbender kit added via entity.actions during player spawn.**  
For now, this is implemented directly in game.py (hacky but functional).  
Long-term: this should be rolled into character generation + template components.

===============================================================================
SECTION 4 — TARGETING (NEXT MAJOR REWRITE)

Goal:
One unified TargetMode for everything:
- Rune terminus / seed
- Activate (radius / neighbors)
- Look mode
- Ranged attacks
- Teleports

TargetState (scene-owned):
- active, kind ("tile"/"vertex"), action_name
- cursor, origin, optional range

Renderer: just draws cursor.  
Game: receives final target on confirm.  

This is the next major structural refactor.

===============================================================================
SECTION 5 — DATA-DRIVEN ENTITIES

Entities and actors created via YAML templates using a factory.  
Supports:
✓ Monsters with custom AI + action sets  
✓ Items with HP, tags, container behavior  
✓ Procedural or mythic biological systems

Vision:
- Retire hardcoded stats in game.py
- Move to component-style behaviors in templates

===============================================================================
SECTION 6 — PRACTICAL ONBOARDING NOTES

For new contributors:
- Renderer is view-only; never handle input here.
- Scenes own UI and all state machines (ability bar, targeting, dialogs).
- Game holds state; systems/* holds logic.
- View-models flow from scenes → renderer only.
- Actions define all UI metadata; the renderer never invents any.

===============================================================================
SECTION 7 — TL;DR FOR THE NEXT GUY

ascii.py: pure renderer  
Scene: owns UI, input, and routing  
Game: pure world state  
Actions: define ability metadata  
AbilityBar: driven by entity.actions  
Dynamic abilities: use `Game.grant_ability` when unlocking actions (items, customs, NPC rewards) so the bar stays in sync.  
Cooldowns: ActionDef.cooldown_ticks; cooldowns live on the action origin (actor or item) and tick down in game-time so item-bound abilities keep their cooldown across owners.  
POIs: content/pois.yaml defines point-of-interest data (coords, NPC/item spawns). mapgen.apply_pois tags worlds; Game._spawn_poi_contents populates NPCs/items when a zone is built (e.g., Academy NPCs).  
Renderer purge (in progress): move hover/aim/config state and Lorenz integration out of ascii.py; renderer should consume view-models only (legacy urgent overlay removed).  
Next priority: Unified TargetMode

Keep the geometry weird and the scenes clean.

�o" Hover/aim/config state now scene-owned (DungeonUIState); renderer consumes view-model only

�o" Lorenz: simulation/state in game/lorenz; renderer draws from game.lorenz_* view data (trails only).

