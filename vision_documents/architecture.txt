EDGECASTER ARCHITECTURE GUIDE
High-Level Overview and Refactor Roadmap
Updated: 2025-12-08

This document orients new contributors to the current post-ascii-purge structure.
It should be kept concise, accurate, and immediately actionable.

===============================================================================
SECTION 1 — LAYER RESPONSIBILITIES

SCENES (edgecaster/scenes/)
Scenes own:
- Input interpretation (via GameCommand)
- UI state (dialog, config, ability bar, targeting)
- Scene transitions
- High-level game intentions (“Player wants to activate this ability”)

Scenes DO NOT:
- draw pixels
- embed render logic
- mutate renderer state

Key scenes:
manager.py   → scene stack + transitions
dungeon.py   → main gameplay; owns ability bar + targeting
inventory_scene.py
dialogue_scene.py
fractal_editor_scene.py
urgent_message_scene.py

RENDERERS (edgecaster/render/)
Renderers are PURE VIEW.

ascii.py:
- Draws world, entities, HUD, overlays
- Computes hitboxes for mouse interactions
- Holds only lightweight visual state (highlight index, hover info)

Renderers DO NOT:
- read keyboard/mouse events
- route abilities or game actions
- own gameplay logic

INPUT (edgecaster/scenes/game_input.py)
Single translation layer:
Pygame event → GameCommand(kind="move"|"ability_hotkey"|...)
Scenes respond to GameCommand; renderer is never involved.

GAME CORE (edgecaster/game.py)
Authoritative world state:
- Actors, entities, turn queue
- Movement, combat, fractal mechanics
- Custom patterns, illumination, state updates

Does NOT:
- know about Pygame
- know about renderer
- interpret input

SYSTEMS (edgecaster/systems/)
Pure logic modules:
- actions.py → atomic actions + metadata (show_in_bar, icon, sub-buttons)
- abilities.py → ability building + effect routing
- patterns/* → fractal generation
- ai.py → behavior logic

NOTE ON ACTION METADATA (NEW):
Action UI metadata—icons, hover text, and optional sub-buttons—is defined
centrally in actions.py. The AbilityBarRenderer imports these values and
constructs its visual elements dynamically. No UI configuration is stored inside
the renderer or scene code. This allows actions to be extended or reskinned
purely through content-layer definitions.

===============================================================================
SECTION 2 — STATE OF THE ASCII PURGE

Originally ascii.py contained input, UI logic, aim mode, ability routing, dialog
logic, and sometimes gameplay. It is now almost fully purified.

Current status:
✓ All input is in DungeonScene
✓ Ability system moved to systems/abilities.py
✓ AbilityBarState + AbilityBarRenderer implemented (scene model + renderer view)
✓ DungeonScene handles all activations + hotkeys
✓ Targeting logic partially moved out; renderer only draws cursor/hover
✓ Action icons + sub-buttons now driven entirely by actions.py metadata

Remaining impurities:
- Dialog overlay logic still partially embedded in ascii.py
- Config gear menu still renderer-owned

Next steps:
→ Move dialog/config UI into dedicated scenes
→ Complete TargetMode generalization

===============================================================================
SECTION 3 — ABILITY SYSTEM (CURRENT STATUS)

Abilities are no longer renderer-driven. Pipeline:

Actor.actions (from YAML or class) + Game character state →
systems/abilities.build_abilities →
AbilityBarState (scene-owned) →
AbilityBarRenderer (view-only) →
DungeonScene._handle_command → trigger_ability_effect / queue_player_action

Highlights:
✓ Actions declare show_in_bar metadata
✓ Icons, colors, and sub-button definitions now originate in actions.py
✓ Renderer becomes a pure consumer of metadata instead of storing UI logic
✓ Hosts (imps, future classes) automatically expose abilities
✓ Ability bar is dynamic and reorderable

NEW: ACTION SUB-BUTTONS
Actions may optionally define sub-buttons (e.g. +/–, gear icons, parameter
adjusters). These are declared in actions.py, and AbilityBarRenderer generates
the corresponding hitboxes and icon renderings automatically. DungeonScene
receives click events and routes them based on spec.id and spec.kind.

===============================================================================
SECTION 4 — TARGETING REWRITE (NEXT PIVOTAL TASK)

Goal:
One unified TargetMode used for:
- Rune terminus placement
- Activate-all / activate-seed
- Look mode
- Future ranged attacks, teleports, cone AoEs

TargetState will include:
active, kind ("tile"/"vertex"), action, cursor, origin, optional range.

Rules:
- While active → movement keys move cursor, not player
- Confirm → dispatch correct action with resolved target data
- Cancel → exit TargetMode
- Renderer → draws cursor only; no logic

This is the next major refactor before introducing class action sets or advanced UI.

===============================================================================
SECTION 5 — DATA-DRIVEN ENTITIES

items, berries, containers, and environmental objects are now defined in
entities.yaml. A factory (mirroring enemies.yaml) instantiates Entities with:

id, glyph/color, layer, physics flags, tags, statuses.

Vision:
Everything in the world is an Entity; subclasses (Object → Organism → Animal)
become composable behaviors instead of hard-coded Python.

Supports:
✓ Sentient berries
✓ HP for items
✓ Procedurally mixed biology / myth / material entities

===============================================================================
SECTION 6 — PRACTICAL ONBOARDING NOTES

For new contributors:
- Renderer is draw-only; NEVER handle input or call game logic there.
- Scenes own UI and command routing.
- Use GameCommand for all new inputs.
- Game holds state; systems/* holds logic.
- View models (AbilityBarState, TargetState, DialogViewModel) travel from scenes
  to renderer, never the reverse.
- Actions define their own UI metadata; renderer simply reflects it.

===============================================================================
SECTION 7 — TL;DR FOR THE NEXT GUY

ascii.py is almost pure view code.
Ability system is fully extracted.
Action icons + sub-buttons come from actions.py.
Next: implement unified TargetMode in DungeonScene.
Keep renderer clean. Keep game pure. Keep scenes in control.

