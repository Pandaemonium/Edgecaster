﻿EDGECASTER ARCHITECTURE GUIDE
High-Level Overview and Refactor Roadmap
Updated: 2025-12-11 (VisualProfile integration, mirrored-world effects, panel-local UI)

This document orients new contributors to the post-ascii-purge structure.
It must remain concise, accurate, and immediately useful as a project primer.

===============================================================================
SECTION 1 — LAYER RESPONSIBILITIES

SCENES (edgecaster/scenes/)
Own:
- Input interpretation (via GameCommand)
- UI state (dialogs, config menus, ability bar, targeting)
- Scene transitions
- High-level gameplay “intent routing”

Do NOT:
- Perform rendering
- Mutate renderer state directly
- Implement world rules or physics

Key scenes:
- manager.py                     scene stack + transitions
- dungeon.py                     primary gameplay; owns ability bar + TargetMode
- urgent_message_scene.py        popup system using panel-local rendering
- dialogue_scene.py              dialogue trees + callbacks
- inventory_scene.py             nested inventories
- options, keybinds, character creation, etc.

-------------------------------------------------------------------------------
RENDERERS (edgecaster/render/)
Pure view layer.

ascii.py:
- Draws map, entities, overlays
- Draws panel-local UI for menu/popup scenes
- Supports global visual transforms (mirror, rotate, scale) via VisualProfile
- Computes hitboxes for mouse interactions (in panel space)

Renderers never:
- Read events
- Interpret commands
- Store gameplay state

-------------------------------------------------------------------------------
INPUT (scenes/game_input.py)
Single layer translating:
Pygame Event → GameCommand(kind="move"|"look_action"|"ability_hotkey"|...)

Scenes interpret GameCommands. The renderer remains input-agnostic.
Keybind persistence merges user settings with DEFAULT_BINDINGS on load, so new
commands (e.g., toggle_door) automatically appear even on older saves; any
command added to DEFAULT_BINDINGS will surface in the keybinds menu under a
category or the auto-added “Other” section.
Keybinds UI (keybinds_scene.py) is data-driven: any command in DEFAULT_BINDINGS
is listed; conflicts are resolved per scene-context so the same key is not
bound to two actions in the same scene.

-------------------------------------------------------------------------------
GAME CORE (edgecaster/game.py)
Authoritative simulation:
- Entities, actors, stats
- Turn updates, movement, collisions, combat
- Fractal mechanics / rune interactions
- Procedural world state, RNG

Does NOT:
- Know about rendering
- Contain UI hints or targeting logic

POIs and content:
- Points of Interest are defined in content/pois.yaml (coord-bound), and can
  spawn NPCs, structures, and items. Mapgen calls apply_pois(...) to mark the
  world, then _spawn_poi_contents populates entities. Structures route through
  mapgen helpers (e.g., item depots, labs) instead of hardcoded coords.
- Entities/features/items live in content/entities.yaml (data-first); enemies in
  content/enemies.yaml; NPC definitions in content/npcs.py.
- Structures (e.g., item depots, lab) are generated in mapgen and described by
  POIs; avoid hard-coding coordinates in code—add POIs instead. Dynamic POIs
  (e.g., the lab) can be injected at runtime by replacing POIS entries with
  their chosen coord.
Abilities and actions:
- Actions and targeting live in systems/actions.py; abilities are just actions
  surfaced via abilities.py and the AbilityBarState. Adding a new action should
  declare its targeting metadata so scenes can enter TargetMode without renderer
  logic changes. Ability icons and pages are built from AbilityBarState.
- Per-action tunables (gear icons) are defined in Game.param_defs (game.py);
  adding params there makes them available to the config overlay automatically.

-------------------------------------------------------------------------------
SYSTEMS (edgecaster/systems/)
Pure logic modules:
- actions.py         → ActionDef metadata + targeting rules
- abilities.py       → Actor-specific action lists
- patterns/*         → Fractal generation
- ai.py              → Behavior stubs

NEW:
✓ All UI-facing action metadata lives in actions.py  
✓ Targeting rules declared in Action.targeting  
✓ AbilityBar is fully metadata-driven

===============================================================================
SECTION 2 — ASCII PURGE STATUS

✓ ascii.py is draw-only  
✓ All targeting state in DungeonUIState  
✓ All input routed through DungeonScene  
✓ Lorenz trail simulation moved out of renderer  
Minor remainder: some temporary overlay styling still lives in ascii.py.

-------------------------------------------------------------------------------
SECTION 2B — VISUAL SCENE SYSTEM (NEW FOUNDATION)

We now support true transform-driven UI using panel-local rendering.

visuals.py introduces:
- VisualProfile (scale_x/y, offset_x/y, angle, alpha, flip_x/y)
- apply_visual_panel(...)  → transforms + draws a panel into the display
- unproject_mouse(...)      → inverts transformations for accurate mouse hit-testing

SceneManager:
- Holds a global VisualProfile for world-level effects (e.g., cursed mirror)
- Supplies per-window VisualProfiles to popup scenes

Panel-local UI:
- PopupMenuScene, UrgentMessageScene, DialoguePopupScene, OptionsScene migrated
- All menus draw into local surfaces sized exactly to their window_rect
- Transform applied at blit-time, never altering underlying logic

Use cases now enabled:
- Rotated popups ("clockwise inventory")
- Mirrored world ("eye curse")
- Recursive menu distortions
- Future dungeon-space effects (wobble, holographic UI, overlaid diagnostics)

Future: unify all scene rendering under a consistent transform stack.

===============================================================================
SECTION 3 — TARGETING (UNIFIED TARGETMODE)

TargetingSpec (in actions.py) defines:
- kind: tile | vertex | look
- mode: aim | terminus | inspect
- range parameters

TargetState (scene-owned) contains cursor, origin, mode, etc.

DungeonScene:
- Handles movement of cursor
- Confirms/cancels
- Calls action effects or Look/Inspect popup

Renderer:
- Draws cursor only; does no targeting logic

Implemented:
✓ tile-based placement  
✓ vertex-based fractal activation  
✓ look/inspect (with entity inheritance)  

===============================================================================
SECTION 4 — DATA-DRIVEN ENTITIES & INHERITANCE

YAML prototypes define:
- parent  
- glyph, color  
- description (inherited automatically)  
- stats, tags

Loader resolves full parent chains.
Runtime entities reference final archetypes.
Look-mode displays inherited descriptions.

Goal: expand to components (AI flags, physiology, materials).

===============================================================================
SECTION 5 — PRACTICAL ONBOARDING NOTES

- Renderer = view-only.  
- Scenes = all UI, transitions, targeting, dialogs.  
- Game = simulation only.  
- Actions = metadata + targeting.  
- Entities = data-driven and hierarchical.

-------------------------------------------------------------------------------
SECTION 6 — CURRENT STRATEGIC WORK

- Consolidate menu layout using VisualProfile pipeline
- Reduce ad-hoc menu scenes (char select, keybindings, custom runes)
- Expand transform-based UI effects
- Extend entity components + procedural lore
Open doc gaps to address:
- Brief primer on POI format + structures (content/pois.yaml, mapgen hooks).
- Brief primer on AbilityBarState and how abilities are synced from abilities.py.
- Note world map rendering cache (scene manager spawns background thread).
