EDGECASTER ARCHITECTURE GUIDE
High-Level Overview and Refactor Roadmap
Updated: 2025-12-08

This document orients new contributors to the current post-ascii-purge structure.
It should be kept concise, accurate, and immediately actionable.

===============================================================================
SECTION 1 — LAYER RESPONSIBILITIES

SCENES (edgecaster/scenes/)
Scenes own:
- Input interpretation (via GameCommand)
- UI state (dialog, config, ability bar, targeting)
- Scene transitions
- High-level game intentions (“Player wants to activate this ability”)

Scenes DO NOT:
- draw pixels
- embed render logic
- mutate renderer state

Key scenes:
manager.py   → scene stack + transitions
dungeon.py   → main gameplay; owns ability bar + targeting
inventory_scene.py
dialogue_scene.py
fractal_editor_scene.py
urgent_message_scene.py

RENDERERS (edgecaster/render/)
Renderers are PURE VIEW.

ascii.py:
- Draws world, entities, HUD, overlays
- Computes hitboxes for mouse interactions
- Holds only lightweight visual state (highlight index, hover info)

Renderers DO NOT:
- read keyboard/mouse events
- route abilities or game actions
- own gameplay logic

INPUT (edgecaster/scenes/game_input.py)
Single translation layer:
Pygame event → GameCommand(kind="move"|"ability_hotkey"|...)
Scenes respond to GameCommand; renderer is never involved.

GAME CORE (edgecaster/game.py)
Authoritative world state:
- Actors, entities, turn queue
- Movement, combat, fractal mechanics
- Custom patterns, illumination, state updates

Does NOT:
- know about Pygame
- know about renderer
- interpret input

SYSTEMS (edgecaster/systems/)
Pure logic modules:
- actions.py → atomic actions + metadata (show_in_bar)
- abilities.py → ability building + effect routing
- patterns/* → fractal generation
- ai.py → behavior logic

===============================================================================
SECTION 2 — STATE OF THE ASCII PURGE

Originally ascii.py contained input, UI logic, aim mode, ability routing, dialog
logic, and sometimes gameplay. It is now almost fully purified.

Current status:
✓ All input is in DungeonScene
✓ Ability system moved to systems/abilities.py
✓ AbilityBarState + AbilityBarRenderer implemented (scene model + renderer view)
✓ DungeonScene handles all activations + hotkeys
✓ Targeting logic partially moved out; renderer only draws cursor/hover

Remaining impurities:
- Dialog overlay logic still partially embedded in ascii.py
- Config gear menu still renderer-owned

Next steps:
→ Move dialog/config UI into dedicated scenes
→ Complete TargetMode generalization

===============================================================================
SECTION 3 — ABILITY SYSTEM (CURRENT STATUS)

Abilities are no longer renderer-driven. Pipeline:

Actor.actions (from YAML or class) + Game character state →
systems/abilities.build_abilities →
AbilityBarState (scene-owned) →
AbilityBarRenderer (view-only) →
DungeonScene._handle_command → trigger_ability_effect / queue_player_action

Highlights:
✓ Actions declare show_in_bar metadata
✓ Hosts (imps, future classes) automatically expose abilities
✓ Ability bar is dynamic and reorderable
✓ Renderer knows only about drawing

===============================================================================
SECTION 4 — TARGETING REWRITE (NEXT PIVOTAL TASK)

Goal:
One unified TargetMode used for:
- Rune terminus placement
- Activate-all / activate-seed
- Look mode
- Future ranged attacks, teleports, cone AoEs

TargetState will include:
active, kind ("tile"/"vertex"), action, cursor, origin, optional range.

Rules:
- While active → movement keys move cursor, not player
- Confirm → dispatch correct action with resolved target data
- Cancel → exit TargetMode
- Renderer → draws cursor only; no logic

This is the next major refactor before introducing class action sets or advanced UI.

===============================================================================
SECTION 5 — DATA-DRIVEN ENTITIES

items, berries, containers, and environmental objects are now defined in
entities.yaml. A factory (mirroring enemies.yaml) instantiates Entities with:

id, glyph/color, layer, physics flags, tags, statuses.

Vision:
Everything in the world is an Entity; subclasses (Object → Organism → Animal)
become composable behaviors instead of hard-coded Python.

Supports:
✓ Sentient berries
✓ HP for items
✓ Procedurally mixed biology / myth / material entities

===============================================================================
SECTION 6 — PRACTICAL ONBOARDING NOTES

For new contributors:
- Renderer is draw-only; NEVER handle input or call game logic there.
- Scenes own UI and command routing.
- Use GameCommand for all new inputs.
- Game holds state; systems/* holds logic.
- View models (AbilityBarState, TargetState, DialogViewModel) travel from scenes
  to renderer, never the reverse.

===============================================================================
SECTION 7 — TL;DR FOR THE NEXT GUY

ascii.py is almost pure view code.
Ability system is fully extracted.
Next: implement unified TargetMode in DungeonScene.
Keep renderer clean. Keep game pure. Keep scenes in control.

:contentReference[oaicite:1]{index=1}
